# 后端架构说明文档

## 📋 概述

本文档说明图宝（Tupal）后端的架构设计和代码组织结构。后端采用 Flask 框架，遵循模块化、分层架构的设计理念。

**最后更新**: 2025-12-04  
**架构版本**: v2.0

---

## 🏗️ 整体架构

```
backend/
├── app.py                 # Flask 主应用入口
├── config.py             # 配置管理
├── requirements.txt      # Python 依赖
├── .env.example         # 环境变量模板
│
├── api/                 # API 层（路由和接口）
│   ├── __init__.py      # 蓝图统一导出
│   ├── routes/          # 功能域路由模块
│   │   ├── outline.py   # 大纲生成
│   │   ├── image.py     # 图片生成
│   │   ├── history.py   # 历史记录
│   │   ├── trending.py  # 热榜数据
│   │   ├── upload.py    # 文件上传
│   │   └── material.py  # 素材管理
│   └── utils/           # API 工具
│       └── response.py  # 统一响应格式
│
├── services/            # 服务层（业务逻辑）
│   ├── outline_service.py
│   ├── image_service.py
│   ├── history_service.py
│   ├── material_service.py
│   ├── trending_service.py
│   └── progress_service.py
│
├── generators/          # AI 生成器层（三层架构）
│   ├── base.py          # 基类定义
│   ├── factory.py       # 生成器工厂
│   ├── prompts/         # 提示词模板层
│   ├── clients/         # API 客户端层
│   │   ├── text/        # 文本客户端
│   │   └── image/       # 图片客户端
│   └── generators/      # 生成器实现层
│
├── models/              # 数据模型层
│   └── material.py
│
├── storage/             # 存储层
│   ├── material_storage.py
│   └── history_storage.py
│
├── sources/             # 数据源层（热榜抓取）
│   ├── base_source.py
│   ├── source_manager.py
│   └── [各平台热榜源]
│
└── utils/              # 工具层
    └── file_utils.py
```

---

## 📦 分层架构说明

### 1. API 层 (`api/`)

**职责**: 处理 HTTP 请求和响应，参数验证，调用服务层

#### 路由模块 (`api/routes/`)

按功能域组织的路由文件，每个文件负责一个独立的业务领域：

| 路由文件 | 功能域 | 主要端点 |
|---------|--------|---------|
| `outline.py` | 大纲生成 | `POST /api/generate-outline` |
| `image.py` | 图片生成 | `POST /api/generate-images`<br>`GET /api/progress/<task_id>` |
| `history.py` | 历史记录 | `GET /api/history`<br>`POST /api/history`<br>`DELETE /api/history/<id>` |
| `trending.py` | 热榜数据 | `GET /api/trending`<br>`GET /api/trending/<source_id>` |
| `upload.py` | 文件上传 | `POST /api/upload-reference` |
| `material.py` | 素材管理 | `GET/POST/PUT/DELETE /api/materials` |

#### 统一响应格式 (`api/utils/response.py`)

提供两个核心函数：

```python
# 成功响应
success_response(data=None, message=None, status_code=200)
# 返回: {"success": True, "data": {...}, "message": "..."}

# 错误响应
error_response(error, status_code=500, **kwargs)
# 返回: {"success": False, "error": "..."}
```

**优势**:
- 统一的 API 响应格式
- 简化路由代码
- 易于前端处理

---

### 2. 服务层 (`services/`)

**职责**: 实现核心业务逻辑，协调多个组件完成复杂任务

#### 主要服务

- **OutlineService**: 大纲生成服务
  - 调用 AI 生成器生成内容大纲
  - 验证和格式化大纲数据
  
- **ImageService**: 图片生成服务
  - 批量并发生成图片
  - 进度追踪和管理
  - 提示词构建和优化
  
- **MaterialService**: 素材管理服务
  - 素材 CRUD 操作
  - 素材引用处理
  - @mention 标记解析
  
- **HistoryService**: 历史记录服务
  - 生成历史的保存和查询
  - 搜索和分页
  
- **TrendingService**: 热榜数据服务
  - 多平台热榜数据聚合
  - 缓存管理
  
- **ProgressService**: 进度管理服务
  - 任务进度追踪
  - SSE 实时推送

---

### 3. 生成器层 (`generators/`)

**职责**: 封装不同 AI 服务商的接口，提供统一的生成能力

#### 架构设计 (v3.0 - 简约三层架构)

采用**客户端、生成器、提示词**三层分离的简约设计：

```
generators/
├── base.py              # 基础类定义
├── factory.py           # 生成器工厂
│
├── prompts/             # 提示词模板层
│   ├── text_prompts.py  # 文本生成提示词
│   └── image_prompts.py # 图片生成提示词
│
├── clients/             # API 客户端层
│   ├── text/           # 文本 API 客户端
│   │   ├── openai_client.py
│   │   └── mock_client.py
│   └── image/          # 图片 API 客户端
│       ├── openai_client.py
│       ├── image_api_client.py
│       └── mock_client.py
│
└── generators/          # 生成器实现层
    ├── text_generator.py
    ├── image_generator.py
    └── mock_generator.py
```

**三层职责**:

1. **Clients 层**: 纯粹的 API 调用封装
   - 封装不同厂商的 API 差异
   - 只负责 HTTP 请求和响应处理
   - 命名规范: `*Client`（如 `OpenAITextClient`）

2. **Generators 层**: 单一能力生成单元
   - 组合提示词构建和客户端调用
   - 处理业务逻辑和数据转换
   - 命名规范: `*Generator`（如 `TextGenerator`）
   - 继承自 `BaseGenerator`

3. **Prompts 层**: 提示词模板构建
   - 纯函数实现，无状态
   - 易于测试和复用
   - 示例: `build_outline_prompt()`, `build_image_prompt()`

**设计原则**:
- ✅ **简约**: 最少抽象层次，易于理解
- ✅ **灵活**: 为未来 Multi-Agent 工作流预留扩展空间
- ✅ **清晰**: 职责单一，命名一致
- ✅ **可控**: 用户完全掌控每一层的行为

**使用示例**:

```python
# 通过工厂创建
from generators.factory import GeneratorFactory
from generators.base import ContentType

# 创建文本生成器
text_gen = GeneratorFactory.create_generator('openai', ContentType.TEXT)
result = text_gen.generate(ContentType.TEXT, prompt="如何学习Python")

# 创建图片生成器
image_gen = GeneratorFactory.create_generator('image_api', ContentType.IMAGE)
result = image_gen.generate(ContentType.IMAGE, prompt="一只可爱的猫", width=1080, height=1440)
```

#### 支持的生成器

| 生成器 | 文本生成 | 图片生成 | 用途 |
|--------|---------|---------|------|
| OpenAI | ✅ | ✅ | 全能型（GPT + DALL-E） |
| ImageAPI | ❌ | ✅ | 专业图片生成（nano-banana等） |
| Mock | ✅ | ✅ | 开发测试 |

#### 架构优势

- ✅ **简约清晰**: 三层职责明确，无冗余抽象
- ✅ **易于扩展**: 添加新客户端或生成器只需实现对应接口
- ✅ **完全可控**: 每层独立，用户可精确控制行为
- ✅ **面向未来**: 预留 Workflows 层用于 Multi-Agent 编排
- ✅ **易于测试**: 每层可独立 Mock 和测试

#### 未来扩展方向

预留 `workflows/` 目录用于实现 Multi-Agent 工作流系统：
- Agent 协作编排
- 复杂任务分解
- 多步骤流程管理

---

### 4. 模型层 (`models/`)

**职责**: 定义数据结构和业务实体

#### Material 模型

```python
class Material:
    id: str
    name: str
    type: MaterialType  # TEXT, IMAGE, REFERENCE
    category: str
    content: Dict
    tags: List[str]
    created_at: str
    updated_at: str
```

支持的素材类型：
- **TEXT**: 文本素材（产品介绍、文案模板等）
- **IMAGE**: 图片素材（参考图、风格图等）
- **REFERENCE**: 参考素材（账号、链接等）

---

### 5. 存储层 (`storage/`)

**职责**: 数据持久化和检索

#### 存储实现

- **MaterialStorage**: 素材存储
  - JSON 文件存储
  - 索引管理
  - 搜索和过滤
  
- **HistoryStorage**: 历史记录存储
  - 生成历史保存
  - 分页查询

**存储位置**:
- 统一存储目录: `storage/`（项目根目录）
  - 素材: `storage/materials/`
  - 历史: `storage/history/`

---

### 6. 数据源层 (`sources/`)

**职责**: 抓取各平台热榜数据

#### 支持的平台

- 百度热搜 (`baidu_hot_source.py`)
- 知乎热榜 (`zhihu_hot_source.py`)
- 微博热搜 (`weibo_hot_source.py`)
- B站热门 (`bilibili_hot_source.py`)
- 抖音热榜 (`douyin_hot_source.py`)
- 头条热榜 (`toutiao_hot_source.py`)

#### 特性

- 统一的数据源接口
- 缓存机制（30分钟 TTL）
- 异步并发抓取
- 错误重试和降级

---

## 🔧 核心功能流程

### 1. 内容生成流程

```
用户请求
  ↓
[API层] outline.py 接收请求
  ↓
[服务层] OutlineService.generate()
  ↓
[生成器层] OpenAIGenerator.generate()
  ↓
[API层] 返回统一格式响应
```

### 2. 图片批量生成流程

```
用户请求
  ↓
[API层] image.py 接收请求
  ↓
[服务层] ImageService.generate_batch()
  ├─ 创建进度任务
  ├─ 启动后台线程
  └─ 立即返回 task_id
  
后台线程:
  ├─ 使用线程池并发生成
  ├─ 实时更新进度
  └─ 完成后标记任务状态

前端:
  └─ 通过 SSE 订阅进度更新
```

### 3. 素材引用处理流程

```
用户输入: "使用 @[iPhone素材](mat_001) 生成图片"
  ↓
[服务层] MaterialService.extract_mention_ids()
  ↓ 提取素材ID: ['mat_001']
  ↓
[存储层] MaterialStorage.get_by_ids()
  ↓ 获取素材内容
  ↓
[服务层] MaterialService.process_material_references()
  ↓ 组装增强提示词
  ↓
返回: {enhanced_prompt, reference_images, materials_used}
```

---

## 🎯 设计原则

### 1. 单一职责原则

每个模块、每个类、每个函数只负责一件事：
- 路由层只处理 HTTP
- 服务层只处理业务逻辑
- 存储层只处理数据

### 2. 依赖倒置原则

高层模块不依赖低层模块，都依赖抽象：
- 服务层依赖生成器接口，不依赖具体实现
- 通过工厂模式创建实例

### 3. 开闭原则

对扩展开放，对修改关闭：
- 添加新的生成器：实现 `BaseGenerator` 接口
- 添加新的路由：创建新的路由文件
- 添加新的数据源：实现 `BaseSource` 接口

### 4. 接口隔离原则

客户端不应依赖它不需要的接口：
- 统一响应格式工具
- 最小化的路由接口

---

## 📝 开发指南

### 添加新的 API 端点

1. 在 `api/routes/` 中选择合适的路由文件（或创建新文件）
2. 使用统一响应格式：

```python
from ..utils.response import success_response, error_response

@bp.route('/new-endpoint', methods=['POST'])
def new_endpoint():
    try:
        # 处理请求
        result = service.do_something()
        return success_response(result)
    except Exception as e:
        logger.error(f'Error: {e}', exc_info=True)
        return error_response(str(e), 500)
```

3. 在 `api/routes/__init__.py` 中导出蓝图
4. 在 `app.py` 中注册蓝图

### 添加新的服务

1. 在 `services/` 中创建服务类
2. 实现业务逻辑方法
3. 在路由中调用服务

### 添加新的 AI 生成器

#### 添加新的 API 客户端

1. 在 `generators/clients/text/` 或 `generators/clients/image/` 中创建新客户端
2. 实现必要的 API 调用方法（如 `generate()`）
3. 处理 API 特定的请求和响应格式

```python
# 示例: generators/clients/text/new_client.py
class NewTextClient:
    def __init__(self, api_key: str, base_url: str):
        self.api_key = api_key
        self.base_url = base_url
    
    def generate(self, prompt: str, **kwargs):
        # 实现 API 调用逻辑
        pass
```

#### 添加新的生成器

1. 在 `generators/generators/` 中创建新生成器类
2. 继承 `BaseGenerator`
3. 在 `__init__` 中初始化所需的客户端
4. 实现 `generate()` 方法

```python
# 示例: generators/generators/new_generator.py
from ..base import BaseGenerator, ContentType, GenerationResult
from ..clients.text.new_client import NewTextClient

class NewGenerator(BaseGenerator):
    def __init__(self, api_key: str):
        super().__init__('new_provider')
        self.client = NewTextClient(api_key)
    
    def generate(self, content_type: ContentType, **kwargs) -> GenerationResult:
        # 调用客户端生成内容
        pass
```

3. 在 `generators/factory.py` 中注册新生成器

---

## 🔒 安全考虑

1. **API Key 管理**: 所有敏感信息存储在 `.env` 文件中
2. **输入验证**: 路由层进行参数验证
3. **错误处理**: 统一的异常处理，不暴露内部细节
4. **CORS 配置**: 限制允许的来源
5. **文件上传**: 限制文件大小和类型

---

## 🚀 性能优化

1. **并发生成**: 图片生成使用线程池，最大并发 25
2. **缓存机制**: 热榜数据缓存 30 分钟
3. **异步处理**: 长时间任务在后台线程执行
4. **SSE 推送**: 实时进度更新，避免轮询

---

## 📊 监控和日志

### 日志级别

- **INFO**: 正常业务流程
- **WARNING**: 可恢复的异常
- **ERROR**: 需要关注的错误

### 关键日志点

- API 请求和响应
- 服务调用和结果
- 生成器调用和耗时
- 错误和异常堆栈

---

## 🔄 版本历史

### v3.0 (2024-12-04)

**Generators 架构重构**:
- ✅ 简约三层架构：Clients → Generators → Prompts
- ✅ 命名规范统一：`*Client` 和 `*Generator`
- ✅ 职责清晰分离：API 调用、业务逻辑、提示词构建
- ✅ 面向未来扩展：预留 Multi-Agent 工作流空间
- ✅ 完全重写：删除旧代码，不向后兼容

**设计理念**:
- 简约：最少抽象层次
- 灵活：易于扩展 Multi-Agent
- 清晰：职责单一，命名一致
- 可控：用户完全掌控

### v2.0 (2024-12-04)

**路由模块化重构**:
- ✅ 路由模块化：按功能域拆分为 6 个独立路由文件
- ✅ 统一响应格式：`success_response()` 和 `error_response()`
- ✅ 清晰的分层架构：API → Service → Generator → Storage
- ✅ 向后兼容：所有 URL 路径保持不变

### v1.0 (2024-11)

- 初始版本
- 单一路由文件
- 基础功能实现

---

## 📚 相关文档

- [API 接口文档](../backend/README.md)
- [设计规范](./设计规范（涉及ui改动需要读取）.md)

---

**维护者**: Kiro AI  
**联系方式**: 通过项目 Issue 反馈问题